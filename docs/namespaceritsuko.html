<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ritsuko: ritsuko Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ritsuko
   </div>
   <div id="projectbrief">Helper utilities for ArtifactDB C++ code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ritsuko Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Assorted helper functions for parsing and validation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceritsuko_1_1hdf5.html">hdf5</a></td></tr>
<tr class="memdesc:namespaceritsuko_1_1hdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assorted helper functions for HDF5 parsing. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structritsuko_1_1FloatExtremes.html">FloatExtremes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extremes for float types.  <a href="structritsuko_1_1FloatExtremes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structritsuko_1_1IntegerExtremes.html">IntegerExtremes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extremes for integer types.  <a href="structritsuko_1_1IntegerExtremes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structritsuko_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structritsuko_1_1Version.html" title="Version number.">Version</a> number.  <a href="structritsuko_1_1Version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e2efff2630c08b7145f28b6dd0caaac" id="r_a1e2efff2630c08b7145f28b6dd0caaac"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a1e2efff2630c08b7145f28b6dd0caaac"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, Type_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1e2efff2630c08b7145f28b6dd0caaac">choose_missing_integer_placeholder</a> (Iterator start, Iterator end, Mask mask)</td></tr>
<tr class="separator:a1e2efff2630c08b7145f28b6dd0caaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a9e4b90108738c8c487c4346d63e61" id="r_a50a9e4b90108738c8c487c4346d63e61"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a50a9e4b90108738c8c487c4346d63e61"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, Type_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a50a9e4b90108738c8c487c4346d63e61">choose_missing_integer_placeholder</a> (Iterator start, Iterator end)</td></tr>
<tr class="separator:a50a9e4b90108738c8c487c4346d63e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0d04408fd63a41f12337d8e27b20f9" id="r_a8f0d04408fd63a41f12337d8e27b20f9"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a8f0d04408fd63a41f12337d8e27b20f9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, Type_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8f0d04408fd63a41f12337d8e27b20f9">choose_missing_float_placeholder</a> (Iterator start, Iterator end, Mask mask, bool skip_nan)</td></tr>
<tr class="separator:a8f0d04408fd63a41f12337d8e27b20f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6039e4e9382e5e3c5ccab69df2a277ba" id="r_a6039e4e9382e5e3c5ccab69df2a277ba"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a6039e4e9382e5e3c5ccab69df2a277ba"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, Type_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6039e4e9382e5e3c5ccab69df2a277ba">choose_missing_float_placeholder</a> (Iterator start, Iterator end, bool skip_nan=false)</td></tr>
<tr class="separator:a6039e4e9382e5e3c5ccab69df2a277ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c6e27babd86a5aecba5bac407d0bab" id="r_ac4c6e27babd86a5aecba5bac407d0bab"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:ac4c6e27babd86a5aecba5bac407d0bab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structritsuko_1_1IntegerExtremes.html">IntegerExtremes</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac4c6e27babd86a5aecba5bac407d0bab">find_integer_extremes</a> (Iterator start, Iterator end, Mask mask)</td></tr>
<tr class="separator:ac4c6e27babd86a5aecba5bac407d0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21392ec88948b3ab1cf711fd6859c73c" id="r_a21392ec88948b3ab1cf711fd6859c73c"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a21392ec88948b3ab1cf711fd6859c73c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structritsuko_1_1IntegerExtremes.html">IntegerExtremes</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a21392ec88948b3ab1cf711fd6859c73c">find_integer_extremes</a> (Iterator start, Iterator end)</td></tr>
<tr class="separator:a21392ec88948b3ab1cf711fd6859c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bea39bbb6bbd8c7231c1ad5a4dcb674" id="r_a7bea39bbb6bbd8c7231c1ad5a4dcb674"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a7bea39bbb6bbd8c7231c1ad5a4dcb674"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structritsuko_1_1FloatExtremes.html">FloatExtremes</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7bea39bbb6bbd8c7231c1ad5a4dcb674">find_float_extremes</a> (Iterator start, Iterator end, Mask mask, bool skip_nan)</td></tr>
<tr class="separator:a7bea39bbb6bbd8c7231c1ad5a4dcb674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd6f2a837cf833fb145dcedb2334012" id="r_a6fd6f2a837cf833fb145dcedb2334012"><td class="memTemplParams" colspan="2">template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </td></tr>
<tr class="memitem:a6fd6f2a837cf833fb145dcedb2334012"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structritsuko_1_1FloatExtremes.html">FloatExtremes</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fd6f2a837cf833fb145dcedb2334012">find_float_extremes</a> (Iterator start, Iterator end, bool skip_nan=false)</td></tr>
<tr class="separator:a6fd6f2a837cf833fb145dcedb2334012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbbf9102b54e6f3f2f11bd0bdb721d8" id="r_a0dbbf9102b54e6f3f2f11bd0bdb721d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dbbf9102b54e6f3f2f11bd0bdb721d8">is_date_prefix</a> (const char *ptr)</td></tr>
<tr class="separator:a0dbbf9102b54e6f3f2f11bd0bdb721d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53ad376d532eaac211b7cd93f3dda4c" id="r_af53ad376d532eaac211b7cd93f3dda4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af53ad376d532eaac211b7cd93f3dda4c">is_date</a> (const char *ptr, size_t len)</td></tr>
<tr class="separator:af53ad376d532eaac211b7cd93f3dda4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f8ff07715c8177a709e440eb029f30" id="r_ac5f8ff07715c8177a709e440eb029f30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f8ff07715c8177a709e440eb029f30">is_rfc3339_suffix</a> (const char *ptr, size_t len)</td></tr>
<tr class="separator:ac5f8ff07715c8177a709e440eb029f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf542db46552ae71530ecfccd1f66505" id="r_abf542db46552ae71530ecfccd1f66505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf542db46552ae71530ecfccd1f66505">is_rfc3339</a> (const char *ptr, size_t len)</td></tr>
<tr class="separator:abf542db46552ae71530ecfccd1f66505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7609d114de23145d8d28ddde55c810" id="r_aee7609d114de23145d8d28ddde55c810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structritsuko_1_1Version.html">Version</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee7609d114de23145d8d28ddde55c810">parse_version_string</a> (const char *version_string, size_t size, bool skip_patch=false)</td></tr>
<tr class="separator:aee7609d114de23145d8d28ddde55c810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafacebbb1cafbc7637b140730373d1d6" id="r_aafacebbb1cafbc7637b140730373d1d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafacebbb1cafbc7637b140730373d1d6">r_missing_value</a> ()</td></tr>
<tr class="separator:aafacebbb1cafbc7637b140730373d1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c2618a51291704bc7024b1dfc178d8" id="r_a74c2618a51291704bc7024b1dfc178d8"><td class="memTemplParams" colspan="2">template&lt;typename Float_ &gt; </td></tr>
<tr class="memitem:a74c2618a51291704bc7024b1dfc178d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74c2618a51291704bc7024b1dfc178d8">are_floats_identical</a> (const Float_ *x, const Float_ *y)</td></tr>
<tr class="separator:a74c2618a51291704bc7024b1dfc178d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Assorted helper functions for parsing and validation. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a74c2618a51291704bc7024b1dfc178d8" name="a74c2618a51291704bc7024b1dfc178d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c2618a51291704bc7024b1dfc178d8">&#9670;&#160;</a></span>are_floats_identical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Float_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool ritsuko::are_floats_identical </td>
          <td>(</td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Float_ *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for identical floating-point numbers, including NaN status and the payload.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Float_</td><td>Floating-point type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to a floating point value. </td></tr>
    <tr><td class="paramname">y</td><td>Pointer to another floating point value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <code>x</code> and <code>y</code> have identical bit patterns. </dd></dl>

</div>
</div>
<a id="a6039e4e9382e5e3c5ccab69df2a277ba" name="a6039e4e9382e5e3c5ccab69df2a277ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6039e4e9382e5e3c5ccab69df2a277ba">&#9670;&#160;</a></span>choose_missing_float_placeholder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, Type_ &gt; ritsuko::choose_missing_float_placeholder </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a8f0d04408fd63a41f12337d8e27b20f9">choose_missing_float_placeholder()</a></code> where no values are masked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for floating-point values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Integer type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">skip_nan</td><td>Whether to skip NaN as a potential placeholder.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (i) a boolean indicating whether a placeholder was successfully found, and (ii) the chosen placeholder if the previous boolean is true. </dd></dl>

</div>
</div>
<a id="a8f0d04408fd63a41f12337d8e27b20f9" name="a8f0d04408fd63a41f12337d8e27b20f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0d04408fd63a41f12337d8e27b20f9">&#9670;&#160;</a></span>choose_missing_float_placeholder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, Type_ &gt; ritsuko::choose_missing_float_placeholder </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose an appropriate placeholder for missing values in a floating-point dataset, after ignoring all masked values. This will try the various IEEE special values (NaN, Inf, -Inf) and then some type-specific boundaries (the minimum, the maximum, and for signed types, 0) before sorting the dataset and searching for an unused float.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for floating-point values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Float type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">mask</td><td>Start of the mask vector. </td></tr>
    <tr><td class="paramname">skip_nan</td><td>Whether to skip NaN as a potential placeholder. Useful in frameworks like R that need special consideration of NaN payloads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (i) a boolean indicating whether a placeholder was successfully found, and (ii) the chosen placeholder if the previous boolean is true. </dd></dl>

</div>
</div>
<a id="a50a9e4b90108738c8c487c4346d63e61" name="a50a9e4b90108738c8c487c4346d63e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a9e4b90108738c8c487c4346d63e61">&#9670;&#160;</a></span>choose_missing_integer_placeholder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, Type_ &gt; ritsuko::choose_missing_integer_placeholder </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a1e2efff2630c08b7145f28b6dd0caaac">choose_missing_integer_placeholder()</a></code> where no values are masked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for integer values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Integer type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (i) a boolean indicating whether a placeholder was successfully found, and (ii) the chosen placeholder if the previous boolean is true. </dd></dl>

</div>
</div>
<a id="a1e2efff2630c08b7145f28b6dd0caaac" name="a1e2efff2630c08b7145f28b6dd0caaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2efff2630c08b7145f28b6dd0caaac">&#9670;&#160;</a></span>choose_missing_integer_placeholder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, Type_ &gt; ritsuko::choose_missing_integer_placeholder </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose an appropriate placeholder for missing values in an integer dataset, after ignoring all the masked values. This will try the various special values (the minimum, the maximum, and for signed types, 0) before sorting the dataset and searching for an unused integer value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for integer values. </td></tr>
    <tr><td class="paramname">Mask_</td><td>Random access iterator for mask values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Integer type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">mask</td><td>Start of the mask vector. This should have the same length as <code>end - start</code>; each entry is true if the corresponding value of the integer dataset is masked, and false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pair containing (i) a boolean indicating whether a placeholder was successfully found, and (ii) the chosen placeholder if the previous boolean is true. </dd></dl>

</div>
</div>
<a id="a6fd6f2a837cf833fb145dcedb2334012" name="a6fd6f2a837cf833fb145dcedb2334012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd6f2a837cf833fb145dcedb2334012">&#9670;&#160;</a></span>find_float_extremes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structritsuko_1_1FloatExtremes.html">FloatExtremes</a> ritsuko::find_float_extremes </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a7bea39bbb6bbd8c7231c1ad5a4dcb674">find_float_extremes()</a></code> where no values are masked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for float values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Float type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">skip_nan</td><td>Whether to skip searches for NaN. Useful in frameworks like R that need special consideration of NaN payloads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether extreme values are present in <code>[start, end)</code>. </dd></dl>

</div>
</div>
<a id="a7bea39bbb6bbd8c7231c1ad5a4dcb674" name="a7bea39bbb6bbd8c7231c1ad5a4dcb674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bea39bbb6bbd8c7231c1ad5a4dcb674">&#9670;&#160;</a></span>find_float_extremes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structritsuko_1_1FloatExtremes.html">FloatExtremes</a> ritsuko::find_float_extremes </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_nan</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for the presence of extreme values in a floating-point dataset. This can be used to choose a missing placeholder value in an online fashion, by calling this function on blocks of the dataset; if any of the extreme values are absent from all blocks, they can be used as the missing value placeholder. By contrast, <code><a class="el" href="#a8f0d04408fd63a41f12337d8e27b20f9">choose_missing_float_placeholder()</a></code> requires access to the full dataset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for float values. </td></tr>
    <tr><td class="paramname">Mask_</td><td>Random access iterator for mask values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Float type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">mask</td><td>Start of the mask vector. This should have the same length as <code>end - start</code>; each entry is true if the corresponding value of the float dataset is masked, and false otherwise. </td></tr>
    <tr><td class="paramname">skip_nan</td><td>Whether to skip searches for NaN. Useful in frameworks like R that need special consideration of NaN payloads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether extreme values are present in <code>[start, end)</code>. If <code>skip_nan = true</code>, <code><a class="el" href="structritsuko_1_1FloatExtremes.html#a3ceaec59926636a10238dd8afae1010c">FloatExtremes::has_nan</a></code> is set to false and should be ignored. If <code>Type_</code> is not an IEEE754-compliant float, users should ignore <code><a class="el" href="structritsuko_1_1FloatExtremes.html#a3ceaec59926636a10238dd8afae1010c">FloatExtremes::has_nan</a></code>, <code><a class="el" href="structritsuko_1_1FloatExtremes.html#a8029fe3c0ec914716c1dc6c5bb1503eb">FloatExtremes::has_negative_inf</a></code> and <code><a class="el" href="structritsuko_1_1FloatExtremes.html#a5c63ec9bdeefc7cab7a74b85388f4526">FloatExtremes::has_positive_inf</a></code>. </dd></dl>

</div>
</div>
<a id="a21392ec88948b3ab1cf711fd6859c73c" name="a21392ec88948b3ab1cf711fd6859c73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21392ec88948b3ab1cf711fd6859c73c">&#9670;&#160;</a></span>find_integer_extremes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structritsuko_1_1IntegerExtremes.html">IntegerExtremes</a> ritsuko::find_integer_extremes </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#ac4c6e27babd86a5aecba5bac407d0bab">find_integer_extremes()</a></code> where no values are masked.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for integer values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Integer type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether extreme values are present in <code>[start, end)</code>. </dd></dl>

</div>
</div>
<a id="ac4c6e27babd86a5aecba5bac407d0bab" name="ac4c6e27babd86a5aecba5bac407d0bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4c6e27babd86a5aecba5bac407d0bab">&#9670;&#160;</a></span>find_integer_extremes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , class Mask , class Type_  = typename std::remove_cv&lt;typename std::remove_reference&lt;decltype(*(std::declval&lt;Iterator&gt;()))&gt;::type, ::type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structritsuko_1_1IntegerExtremes.html">IntegerExtremes</a> ritsuko::find_integer_extremes </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check for the presence of extreme values in an integer dataset. This can be used to choose a missing placeholder value in an online fashion, by calling this function on blocks of the dataset; if any of the extreme values are absent from all blocks, they can be used as the missing value placeholder. By contrast, <code><a class="el" href="#a1e2efff2630c08b7145f28b6dd0caaac">choose_missing_integer_placeholder()</a></code> requires access to the full dataset.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Iterator_</td><td>Forward iterator for integer values. </td></tr>
    <tr><td class="paramname">Mask_</td><td>Random access iterator for mask values. </td></tr>
    <tr><td class="paramname">Type_</td><td>Integer type pointed to by <code>Iterator_</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>Start of the dataset. </td></tr>
    <tr><td class="paramname">end</td><td>End of the dataset. </td></tr>
    <tr><td class="paramname">mask</td><td>Start of the mask vector. This should have the same length as <code>end - start</code>; each entry is true if the corresponding value of the integer dataset is masked, and false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether extreme values are present in <code>[start, end)</code>. If <code>Type_</code> is unsigned, <code><a class="el" href="structritsuko_1_1IntegerExtremes.html#a37b1c4e904260e685784a7736335a9ec">IntegerExtremes::has_lowest</a></code> and <code><a class="el" href="structritsuko_1_1IntegerExtremes.html#ab42cb12eaa83aa5a3e55515be5438129">IntegerExtremes::has_zero</a></code> are the same. </dd></dl>

</div>
</div>
<a id="af53ad376d532eaac211b7cd93f3dda4c" name="af53ad376d532eaac211b7cd93f3dda4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53ad376d532eaac211b7cd93f3dda4c">&#9670;&#160;</a></span>is_date()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ritsuko::is_date </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a C-style string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the string referenced by <code>ptr</code>, excluding the null terminator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <code>ptr</code> refers to a XXXX-YY-ZZ date, for approximately valid combinations of YY and ZZ (see <code><a class="el" href="#a0dbbf9102b54e6f3f2f11bd0bdb721d8">is_date_prefix()</a></code> for details). </dd></dl>

</div>
</div>
<a id="a0dbbf9102b54e6f3f2f11bd0bdb721d8" name="a0dbbf9102b54e6f3f2f11bd0bdb721d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dbbf9102b54e6f3f2f11bd0bdb721d8">&#9670;&#160;</a></span>is_date_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ritsuko::is_date_prefix </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a string start with a XXXX-YY-ZZ date, for approximately valid combinations of YY and ZZ? (This is only approximate as we do not check the exact correctness of the number of days for each month.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a C-style string containing at least 10 characters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the string starts with a date. </dd></dl>

</div>
</div>
<a id="abf542db46552ae71530ecfccd1f66505" name="abf542db46552ae71530ecfccd1f66505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf542db46552ae71530ecfccd1f66505">&#9670;&#160;</a></span>is_rfc3339()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ritsuko::is_rfc3339 </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a string follow the RFC3339 format? This uses <code><a class="el" href="#a0dbbf9102b54e6f3f2f11bd0bdb721d8">is_date_prefix()</a></code> and <code><a class="el" href="#ac5f8ff07715c8177a709e440eb029f30">is_rfc3339_suffix()</a></code> to check the date and the rest of the timestamp, respectively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a C-style string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the string in <code>ptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the string is RFC3339-compliant. </dd></dl>

</div>
</div>
<a id="ac5f8ff07715c8177a709e440eb029f30" name="ac5f8ff07715c8177a709e440eb029f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f8ff07715c8177a709e440eb029f30">&#9670;&#160;</a></span>is_rfc3339_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ritsuko::is_rfc3339_suffix </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does a string finish with an RFC3339-compliant timestamp, i.e., does the substring starting at <code>T</code> after the date follow the RFC3339 specification? Note that the timestamp validity checks are only approximate as the correctness of leap seconds are not currently considered. It is expected that the start of the string up to the <code>T</code> was already validated with <code><a class="el" href="#a0dbbf9102b54e6f3f2f11bd0bdb721d8">is_date_prefix()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to a character array containing at least 10 characters. This should start from the 10th position in the original string, i.e., <code>T</code> in the timestamp. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">len</td><td>Length of the string in <code>ptr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the string finishes with an RFC3339-compliant timestamp. </dd></dl>

</div>
</div>
<a id="aee7609d114de23145d8d28ddde55c810" name="aee7609d114de23145d8d28ddde55c810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7609d114de23145d8d28ddde55c810">&#9670;&#160;</a></span>parse_version_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structritsuko_1_1Version.html">Version</a> ritsuko::parse_version_string </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>version_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>skip_patch</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">version_string</td><td>Pointer to a version string. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>Length of the <code>version_string</code>. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">skip_patch</td><td>Whether to skip the patch number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code><a class="el" href="structritsuko_1_1Version.html" title="Version number.">Version</a></code> object containing the version number. If <code>skip_patch = true</code>, the <code>patch</code> number is always zero. </dd></dl>

</div>
</div>
<a id="aafacebbb1cafbc7637b140730373d1d6" name="aafacebbb1cafbc7637b140730373d1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafacebbb1cafbc7637b140730373d1d6">&#9670;&#160;</a></span>r_missing_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ritsuko::r_missing_value </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create R's missing value for doubles, allowing us to mimic R's missingness concept in other languages.</p>
<dl class="section return"><dt>Returns</dt><dd>A quiet NaN with a payload of 1954, equivalent to R's double-precision missing value. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
